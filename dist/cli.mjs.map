{
  "version": 3,
  "sources": ["../src/cli.ts"],
  "sourcesContent": ["#!/usr/bin/env node\n/* eslint-disable no-console */\n\nimport hasha from 'hasha'\nimport fg from 'fast-glob'\nimport hashObject from 'hash-obj'\nimport fs from 'fs-extra'\nimport { Command } from 'commander'\nimport { spawnSync as exec } from 'child_process'\nimport pMap from 'p-map'\nimport { cpus } from 'os'\nimport { quoteForSh } from 'puka'\nimport jsYaml from 'js-yaml'\n\nconst { writeFile, readFile } = fs\n\nconst { version } = JSON.parse(\n  (await readFile(new URL('../package.json', import.meta.url))).toString()\n)\nconst lockFileName = '.postmon-lock'\n\nfunction log(message: string, ...rest: any[]): void {\n  // eslint-disable-next-line no-console\n  console.log(`[postmon] ${message}`, ...rest)\n}\n\nlog('Starting', version)\n\nconst program = new Command()\nconst { args } = program\n  .version(version, '-v, --version', 'output the current version')\n  .option('-d, --debug', 'Echo additional debugging messages')\n  .option('-i, --include [globs...]', 'File glob to scan for changes')\n  .option('--name <name>', 'A string identifer for this execution')\n  .argument('[exec...]', 'Command line to execute if there are changes')\n  .parse(process.argv)\n\nconst opts = program.opts()\nconst debug = true\n\nconst numberOfCpus = cpus()?.length\nif (!numberOfCpus || numberOfCpus <= 0) {\n  log(\"Error, can't detect your CPU\")\n  log('result:', cpus())\n  process.exit(1)\n}\nconst numberOfCores = Math.max(1, Math.round(numberOfCpus / 2))\n\nif (debug) {\n  log('args', args)\n  log('cpus', cpus().length)\n  log('cwd:', process.cwd())\n  log('cores:', numberOfCores)\n  log('include', opts.include)\n}\n\nasync function getHashOfDirectory(directoryGlobs: string | string[]) {\n  if (debug) console.log('finding files', directoryGlobs)\n  const files = await fg(directoryGlobs, { dot: true })\n  if (debug) console.timeEnd('finding files')\n  if (debug) console.log('Found', files.length, 'matches')\n\n  const mapper = async (file: string) => {\n    return hasha.fromFile(file, { algorithm: 'md5' })\n  }\n\n  if (debug) console.time('hashing files')\n  const matches = await pMap(files, mapper, { concurrency: numberOfCores })\n  if (debug) console.timeEnd('hashing files')\n\n  if (debug)\n    console.log(\n      'rendered',\n      JSON.stringify(matches).length,\n      'bytes of state object'\n    )\n\n  if (debug) console.time('hashing object')\n  const ret = hashObject([matches.sort(), files.sort()], {\n    algorithm: 'sha512',\n  })\n  if (debug) console.timeEnd('hashing object')\n\n  return ret\n}\n\ninterface PostmonConfig {\n  scripts: {\n    [name: string]: PostmonConfigExecution\n  }\n}\ninterface PostmonConfigExecution {\n  command: string\n  inputs: string[]\n  outputs?: string[]\n}\n\nfunction isDocumentWithKey<T>(keyName: string) {\n  return function (e: any): e is T {\n    return typeof e === 'object' && keyName in e\n  }\n}\n\nasync function doTask(\n  directoryGlob: string | string[],\n  name = 'default',\n  commandLine: string\n): Promise<boolean> {\n  if (!commandLine) throw new Error('Must have a commandLine')\n\n\n  const overallHash = await getHashOfDirectory(directoryGlob)\n  if (debug) log('Current hash', overallHash)\n\n  const rawFile = (await readFile(lockFileName).catch(() => '')).toString()\n\n  const storedHashes =\n    (rawFile[0] === '{' &&\n      (rawFile ? (JSON.parse(rawFile) as Record<string, string>) : {})) ||\n    {}\n\n  if (Object.keys(storedHashes).length === 0)\n    log(`First time setup -- will create ${lockFileName} file if successful...`)\n\n  if (storedHashes?.[name] === overallHash) {\n    log(`No changes detected -- skipping execution.`)\n    return true\n  }\n\n  // Execute\n  log(`Executing: ${commandLine}`)\n  const output = exec(commandLine, {\n    shell: true,\n    stdio: 'inherit',\n  })\n  if (debug) log('output', output)\n\n  // Store results\n  if (output.status === 0) {\n    await writeFile(\n      lockFileName,\n      JSON.stringify({ ...storedHashes, [name]: overallHash })\n    )\n    log(`Written new hash for '${name}' to ${lockFileName}`)\n  }\n\n  return output.status === 0\n}\n\n;(async () => {\n  if (opts.include)\n    doTask(opts.include, opts.name, args.map((e) => quoteForSh(e)).join(' '))\n  else {\n    // Read from .postmon.yml\n    const yml = jsYaml\n      .loadAll(fs.readFileSync('.postmon.yml').toString())\n      .find(isDocumentWithKey<PostmonConfig>('scripts'))\n    if (!yml) throw new Error('Define a .postmon.yml file first.')\n\n    const mapper = await pMap(\n      Object.entries(yml.scripts).filter(([, { command }]) => !!command),\n      ([name, { inputs, command }]) => doTask(inputs, name, command),\n      { concurrency: 1 }\n    )\n\n    console.log('All done.')\n  }\n})()\n"],
  "mappings": "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",
  "names": []
}
